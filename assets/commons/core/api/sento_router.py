"""
DO NOT EDIT! THIS IS AN AUTOGENERATED FILE!!!!!
"""

import os
from typing import Type, List, Optional, Callable, Any, Union, Generator
from fastapi import APIRouter, HTTPException, Depends, BackgroundTasks
from fastapi.security import OAuth2PasswordBearer
from pydantic import BaseModel

from sqlalchemy import inspect
from .authentication import SentoAuth
#from .security import keycloak_openid
from ..logging.logger import logger
from . import (
    T,
    _utils,
    NOT_FOUND,
    NOT_AUTHORIZED,
    DEPENDENCIES,
    PYDANTIC_SCHEMA as SCHEMA,
    PAGINATION
)

try:
    from sqlalchemy.orm import Session
    from sqlalchemy.ext.declarative import DeclarativeMeta as Model
    from sqlalchemy.exc import IntegrityError
except ImportError as e:
    Model = None
    Session = None
    IntegrityError = None
    sqlalchemy_installed = False
else:
    sqlalchemy_installed = True
    Session = Callable[..., Generator[Session, Any, None]]

CALLABLE = Callable[..., Model]
CALLABLE_LIST = Callable[..., List[Model]]


class SentoRouter(APIRouter):
    _base_path: str = "/"


    def __init__(self, schema: Type[T],
                 db_model: Model,
                 db: "Session",
                 create_schema: Optional[Type[SCHEMA]] = None,
                 update_schema: Optional[Type[SCHEMA]] = None,
                 upsert_schema: Optional[Type[SCHEMA]] = None,
                 prefix: Optional[str] = None,
                 tags: Optional[List[str]] = None,
                 paginate: Optional[int] = None,
                 get_all_route: Union[bool, DEPENDENCIES] = True,
                 get_one_route: Union[bool, DEPENDENCIES] = True,
                 create_one_route: Union[bool, DEPENDENCIES] = True,
                 create_all_route: Union[bool, DEPENDENCIES] = True,
                 update_one_route: Union[bool, DEPENDENCIES] = True,
                 get_all_filter_function=None,
                 get_one_filter_function=None,
                 delete_one_route: Union[bool, DEPENDENCIES] = True,
                 delete_all_route: Union[bool, DEPENDENCIES] = True,
                 get_all_filter_meta=None,
                 get_one_filter_meta=None,
                 create_one_callback=False,
                 delete_one_callback=False,
                 delete_all_callback=False,
                 update_one_callback=False,
                 unique_fields=None,
                 **kwargs) -> None:

        self.logger = logger
        self._sqs_client = _utils.get_sqs_client()

        self.schema = schema
        self.db_model = db_model
        self.db_cols = inspect(self.db_model).c
        if unique_fields is None:
            unique_fields = []
        self.unique_fields = unique_fields
        self.db_func = db
        self._pk: str = db_model.__table__.primary_key.columns.keys()[0]
        self._pk_type: type = _utils.get_pk_type(schema, self._pk)

        self.pagination = _utils.pagination_factory(max_limit=paginate)

        self.create_schema = (
            create_schema
            if create_schema
            else _utils.schema_factory(self.schema, pk_field_name=self._pk, name="Create")
        )
        self.update_schema = (
            update_schema
            if update_schema
            else _utils.schema_factory(self.schema, pk_field_name=self._pk, name="Update")
        )

        self.upsert_schema = upsert_schema

        if get_all_filter_function:
            self._get_all_filter_function = get_all_filter_function
        else:
            def params():
                return {}

            self._get_all_filter_function = params
        self.get_all_filter_meta = get_all_filter_meta

        if get_one_filter_function:
            self._get_one_filter_function = get_one_filter_function
        else:
            def params():
                return {}

            self._get_one_filter_function = params
        self.get_one_filter_meta = get_one_filter_meta

        self.create_one_callback = create_one_callback
        self.update_one_callback = update_one_callback

        self.delete_one_callback = delete_one_callback
        self.delete_all_callback = delete_all_callback

        prefix = str(prefix if prefix else self.schema.__name__).lower()
        prefix = self._base_path + prefix.strip("/")
        tags = tags or [prefix.strip("/").capitalize()]

        #self.oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
        #self.keycloak_openid = keycloak_openid

        #self.config_well_know = self.keycloak_openid.well_known()

        super().__init__(prefix=prefix, tags=tags, **kwargs)
        if get_all_route:
            self._add_api_route(
                "",
                self._get_all(),
                methods=["GET"],
                response_model=Optional[List[self.schema]],  # type: ignore
                summary="Get All",
                dependencies=get_all_route,
                error_responses=[NOT_AUTHORIZED,NOT_FOUND]
            )

        if get_one_route:
            self._add_api_route(
                "/{id}",
                self._get_one(),
                methods=["GET"],
                response_model=self.schema,
                summary="Get One",
                dependencies=get_one_route,
                error_responses=[NOT_AUTHORIZED,NOT_FOUND],
            )
        if create_one_route:
            self._add_api_route(
                "",
                self._create(),
                methods=["POST"],
                response_model=self.schema,
                summary="Create One",
                dependencies=get_one_route,
                error_responses=[NOT_AUTHORIZED, NOT_FOUND],
            )
        if create_all_route:
            self._add_api_route(
                "/all",
                self._create_all(),
                methods=["POST"],
                response_model=List[self.schema],
                summary="Create All",
                dependencies=create_all_route,
                error_responses=[NOT_AUTHORIZED, NOT_FOUND],
            )
        if update_one_route:
            self._add_api_route(
                "/{id}",
                self._update(),
                methods=["PUT"],
                response_model=self.schema,
                summary="Update One",
                dependencies=create_one_route,
                error_responses=[NOT_AUTHORIZED, NOT_FOUND],
            )
        if delete_one_route:
            self._add_api_route(
                "/{id}",
                self._delete_one(),
                methods=["DELETE"],
                response_model=self.schema,
                summary="Delete One",
                dependencies=delete_one_route,
                error_responses=[NOT_AUTHORIZED, NOT_FOUND],
            )
        if delete_all_route:

            class DeleteAll(BaseModel):
                status: str

            self._add_api_route(
                "",
                self._delete_all(),
                methods=["DELETE"],
                summary="Delete All",
                response_model=DeleteAll,
                dependencies=delete_all_route,
                error_responses=[NOT_AUTHORIZED, NOT_FOUND],
            )

    def _add_api_route(
            self,
            path: str,
            endpoint: Callable[..., Any],
            dependencies: Union[bool, DEPENDENCIES],
            error_responses: Optional[List[HTTPException]] = None,
            **kwargs: Any,
    ) -> None:
        dependencies = [] if isinstance(dependencies, bool) else dependencies
        responses: Any = (
            {err.status_code: {"detail": err.detail} for err in error_responses}
            if error_responses
            else None
        )
        #dependencies.append(Depends(self.oauth2_scheme))

        super().add_api_route(
            path, endpoint, dependencies=dependencies, responses=responses, **kwargs
        )

    def __push_callback_event(self, event):
        try:
            self._sqs_client.send_message(
                QueueUrl=os.getenv("SQS_EVENT_QUEUE_URL"),
                MessageBody=_utils.to_json(event)
            )
        except Exception as e:
            print(e)

    def _get_all(self, *args: Any, **kwargs: Any) -> CALLABLE_LIST:
        def route(
                args=Depends(self._get_all_filter_function),
                pagination: PAGINATION = self.pagination,
                db: Session = Depends(self.db_func),
                auth: SentoAuth = Depends(SentoAuth)
        ) -> List[Model]:
            skip, limit = pagination.get("skip"), pagination.get("limit")
            query = db.query(self.db_model)

            for k, v in args.items():
                filter_meta = self.get_all_filter_meta.get(k, {})
                if v is not None:
                    if filter_meta.get('condition', '==') == "in":
                        v_split = v.split(",")
                        filter = f"self.db_cols['{filter_meta.get('column', '==')}'].in_(v_split)"
                    else:
                        filter = f"self.db_cols['{filter_meta.get('column', '==')}'] {filter_meta.get('condition', '==')} v"
                    query = query.filter(
                        eval(
                            filter
                        )
                    )
            db_models: List[Model] = (
                query
                    .order_by(getattr(self.db_model, self._pk))
                    .limit(limit)
                    .offset(skip)
                    .all()
            )
            return db_models

        return route

    def _get_one(self, *args: Any, **kwargs: Any) -> CALLABLE:

        def route(
                id: int,
                db: Session = Depends(self.db_func),
                auth: SentoAuth = Depends(SentoAuth)
        ) -> Model:
            model: Model = db.query(self.db_model).get(id)
            if model:
                return model
            else:
                raise NOT_FOUND from None

        return route

    def __push_create_one_callback_event(self, model: dict):
        event = {
            "type": "create-record",
            "model": self.db_model.__table__.name,
            "data": model
        }
        self.__push_callback_event(event)

    def _create(self, *args: Any, **kwargs: Any) -> CALLABLE:
        schema = self.create_schema

        def route(
                model: schema,
                background_task: BackgroundTasks,
                db: Session = Depends(self.db_func),
                auth: SentoAuth = Depends(SentoAuth)
        ) -> Model:
            print(self.db_model.__name__)
            try:

                db_model: Model = self.db_model(**model.dict())
                setattr(db_model, "modified_on", _utils.get_modified_on())
                db.add(db_model)
                db.commit()
                db.refresh(db_model)

                if self.create_one_callback:
                    background_task.add_task(
                        self.__push_create_one_callback_event,
                        _utils.object_as_dict(db_model)
                    )
                return db_model
            except IntegrityError as e:
                print(e)
                db.rollback()
                raise HTTPException(422, "Key already exists") from None
            except Exception as e:
                print(e)
                raise HTTPException(500, str(e)) from None

        return route

    # TODO: implement callback event
    def _create_all(self, *args: Any, **kwargs: Any) -> CALLABLE_LIST:
        schema = self.upsert_schema

        def route(
                models: List[schema],
                background_task: BackgroundTasks,
                db: Session = Depends(self.db_func),
                auth: SentoAuth = Depends(SentoAuth)
        ) -> List[Model]:
            try:
                model_dicts = []
                update_on_id = []

                for model in models:
                    do_update_on_id = False
                    model_dict = model.dict()
                    if len(self.unique_fields) == 0 and "id" in model_dict.keys():
                        id = model_dict.get("id")
                        if id is None:
                            del model_dict["id"]
                        elif id > 0:
                            do_update_on_id = True

                    update_on_id.append(do_update_on_id)
                    model_dicts.append(model_dict)

                instances = _utils.bulk_create_or_update(
                    session=db,
                    model=self.db_model,
                    data=model_dicts,
                    unique_fields=self.unique_fields,
                    do_update_on_id=update_on_id
                )
                db.commit()
                return instances
            except Exception as e:
                db.rollback()
                raise HTTPException(500, e) from None

        return route

    def __push_update_one_callback_event(self, old_model: dict, new_model: dict):
        event = {
            "type": "update-record",
            "model": self.db_model.__table__.name,
            "data": new_model,
            "old_data": old_model
        }
        self.__push_callback_event(event)

    def _update(self, *args: Any, **kwargs: Any) -> CALLABLE:
        schema = self.update_schema

        def route(
                id: int,
                model: schema,  # type: ignore
                background_task: BackgroundTasks,
                db: Session = Depends(self.db_func),
                auth: SentoAuth = Depends(SentoAuth)
        ) -> Model:

            try:
                db_model: Model = self._get_one()(id, db
                , auth
                )
                old_db_model = _utils.object_as_dict(db_model)
                for key, value in model.dict(exclude={self._pk}).items():
                    if hasattr(db_model, key):
                        setattr(db_model, key, value)
                setattr(db_model, "modified_on", _utils.get_modified_on())

                db.commit()
                db.refresh(db_model)

                if self.update_one_callback:
                    background_task.add_task(
                        self.__push_update_one_callback_event,
                        old_db_model,
                        _utils.object_as_dict(db_model)
                    )

                return db_model
            except IntegrityError as e:
                print(e)
                db.rollback()
                raise HTTPException(422, ", ".join(e.args))
            except Exception as e:
                print(e)

        return route

    def __push_delete_all_callback_event(self, models: List[dict]):
        event = {
            "type": "delete-records",
            "model": self.db_model.__table__.name,
            "data": models
        }
        self.__push_callback_event(event)

    def _delete_all(self, *args: Any, **kwargs: Any) -> CALLABLE_LIST:
        def route(
                background_task: BackgroundTasks,
                args=Depends(self._get_all_filter_function),
                db: Session = Depends(self.db_func),
                auth: SentoAuth = Depends(SentoAuth)
        ) -> List[Model]:
            query = db.query(self.db_model)

            for k, v in args.items():
                filter_meta = self.get_all_filter_meta.get(k, {})
                if v is not None:
                    if filter_meta.get('condition', '==') == "in":
                        v_split = v.split(",")
                        filter = f"self.db_cols['{filter_meta.get('column', '==')}'].in_(v_split)"
                    else:
                        filter = f"self.db_cols['{filter_meta.get('column', '==')}'] {filter_meta.get('condition', '==')} v"
                    query = query.filter(
                        eval(
                            filter
                        )
                    )
            if self.delete_all_callback:
                all_models = query.all()
                background_task.add_task(
                    self.__push_delete_all_callback_event,
                    [_utils.object_as_dict(r) for r in all_models]
                )
            query.delete()
            db.commit()

            return {"status": "ok"}

        return route

    def __push_delete_one_callback_event(self, model: Type[SCHEMA]):
        event = {
            "type": "delete-record",
            "model": self.db_model.__table__.name,
            "data": model
        }
        self.__push_callback_event(event)

    def _delete_one(self, *args: Any, **kwargs: Any) -> CALLABLE:
        def route(
                id: int,
                background_task: BackgroundTasks,
                db: Session = Depends(self.db_func),
                auth: SentoAuth = Depends(SentoAuth)
        ) -> Model:
            db_model: Model = self._get_one()(id, db,auth)
            db.delete(db_model)

            if self.delete_one_callback:
                background_task.add_task(
                    self.__push_delete_one_callback_event,
                    _utils.object_as_dict(db_model)
                )
            db.commit()

            return db_model

        return route

    def _raise(self, e: Exception, status_code: int = 422) -> HTTPException:
        print(e)
        raise HTTPException(status_code, ", ".join(e.args)) from e
