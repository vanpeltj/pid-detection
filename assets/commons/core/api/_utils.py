"""
DO NOT EDIT! THIS IS AN AUTOGENERATED FILE!!!!!
"""


import json
import boto3
import pytz
from datetime import datetime
from typing import Optional, Type, Any

from fastapi import Depends, HTTPException
from pydantic import create_model
from sqlalchemy import inspect

from . import T, PYDANTIC_SCHEMA, PAGINATION


class AttrDict(dict):  # type: ignore
    def __init__(self, *args, **kwargs) -> None:  # type: ignore
        super(AttrDict, self).__init__(*args, **kwargs)
        self.__dict__ = self


def get_pk_type(schema: Type[PYDANTIC_SCHEMA], pk_field: str) -> Any:
    try:
        return schema.model_fields[pk_field].annotation
    except KeyError:
        return int


def schema_factory(
        schema_cls: Type[T], pk_field_name: str = "id", name: str = "Create"
) -> Type[T]:
    """
    Is used to create a CreateSchema which does not contain pk
    """

    fields = {
        f.name: (f.type_, ...)
        for f in schema_cls.model_fields.values()
        if f.name != pk_field_name
    }

    name = schema_cls.__name__ + name
    schema = create_model(__model_name=name, **fields)  # type: ignore
    return schema


def create_query_validation_exception(field: str, msg: str) -> HTTPException:
    return HTTPException(
        422,
        detail={
            "detail": [
                {"loc": ["query", field], "msg": msg, "type": "type_error.integer"}
            ]
        },
    )


def pagination_factory(max_limit: Optional[int] = None) -> Any:
    """
    Created the pagination dependency to be used in the router
    """

    def pagination(skip: int = 0, limit: Optional[int] = max_limit) -> PAGINATION:
        if skip < 0:
            raise create_query_validation_exception(
                field="skip",
                msg="skip query parameter must be greater or equal to zero",
            )

        if limit is not None:
            if limit <= 0:
                raise create_query_validation_exception(
                    field="limit", msg="limit query parameter must be greater then zero"
                )

            elif max_limit and max_limit < limit:
                raise create_query_validation_exception(
                    field="limit",
                    msg=f"limit query parameter must be less then {max_limit}",
                )

        return {"skip": skip, "limit": limit}

    return Depends(pagination)


def get_sqs_client():
    return boto3.client("sqs")


def object_as_dict(obj):
    return {c.key: getattr(obj, c.key)
            for c in inspect(obj).mapper.column_attrs}

def get_modified_on():
    datetime_with_timezone = datetime.now(pytz.UTC)
    return datetime_with_timezone


def to_json(obj):
    return json.dumps(
        obj,
        sort_keys=True,
        default=str
    )

def bulk_create_or_update(session, model, data, do_update_on_id, unique_fields=None):
    if unique_fields is None:
        unique_fields = []

    entries = []
    order_dict = {}
    order_upserts = []

    for idx, (record, update_on_id) in enumerate(zip(data, do_update_on_id)):
        if update_on_id is True:
            instance = session.query(model).get(record.get("id"))

            not_unique_data = {k: v for k, v in record.items() if k not in unique_fields}
            for k, v in not_unique_data.items():
                if hasattr(instance, k):
                    setattr(instance, k, v)
            setattr(instance, "modified_on", get_modified_on())
            session.commit()
            session.refresh(instance)
            order_dict[idx] = instance
            continue


        order_upserts.append(idx)
        if len(unique_fields) == 0:
            entries.append(model(**record))
            continue

        if "id" in record.keys():
            del record["id"]

        unique_data = {k: v for k, v in record.items() if k in unique_fields}
        instance = session.query(model).filter_by(**unique_data).first()
        if instance:
            not_unique_data = {k: v for k, v in record.items() if k not in unique_fields}
            for k, v in not_unique_data.items():
                if hasattr(instance, k):
                    setattr(instance, k, v)
            setattr(instance, "modified_on", get_modified_on())
            entries.append(instance)
        else:
            new_entry = model(**record)
            setattr(new_entry, "modified_on", get_modified_on())
            entries.append(new_entry)
    session.bulk_save_objects(entries, return_defaults=True)
    session.commit()

    for entry, idx in zip(entries,order_upserts):
        order_dict[idx] = entry
    all_instances = [order_dict[i] for i in sorted(order_dict)]

    return all_instances
