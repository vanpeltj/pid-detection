"""
DO NOT EDIT! THIS IS AN AUTOGENERATED FILE!!!!!
"""
import requests
import json
import os
import logging
from retry import retry
from datetime import datetime, timedelta
from ..config.Settings import Settings

API_URL = Settings.API_URL
logger = logging.getLogger()


class SentoRequest:

    def __init__(self, username=None, password=None, url=None):
        self.logger = logging.getLogger()
        self.__token = None
        self.__token_expiration = datetime.now()
        self.__refresh_token_expiration = datetime.now()
        self.__username = username
        self.__password = password

        self.API_URL = url

    def build_url(self, path):
        if self.API_URL:
            url = self.API_URL
        else:
            url = API_URL
        if path[0] == "/":
            url = url + path
        else:
            url = url + "/" + path
        return url

    def __retrieve_token(self):
        return ""
        if not self.__username:
            username = Settings.API_USERNAME
        else:
            username = self.__username

        if not self.__password:
            password = Settings.API_PASSWORD
        else:
            password = self.__password

        token_headers = {'Content-Type': 'application/x-www-form-urlencoded',
                         'Accept-Charset': 'UTF-8', 'Retry-After': '1'}

        result = requests.post(url=self.build_url("/token"),
                               headers=token_headers,
                               data={
                                   "username": username,
                                   "password": password
                               })
        token = self.unwrap_result(result)
        self.__token = token
        expires_in = token.get("expires_in", 20) - 20
        expires_in_timestamp = datetime.now() + timedelta(seconds=expires_in)
        self.__token_expiration = expires_in_timestamp

        refresh_expires_in = token.get("refresh_expires_in", 20) - 20
        refresh_expires_in_timestamp = datetime.now() + timedelta(seconds=refresh_expires_in)
        self.__refresh_token_expiration = refresh_expires_in_timestamp

    def __refresh_token(self):
        return ""
        refresh_token = self.__token.get("refresh_token", None)
        if refresh_token:
            token_headers = {'Content-Type': 'application/x-www-form-urlencoded',
                             'Accept-Charset': 'UTF-8', 'Retry-After': '1'}
            result = requests.post(url=self.build_url(f"/refresh_token?refresh_token={refresh_token}"),
                                   headers=token_headers)
            token = self.unwrap_result(result)
            self.__token = token

    def __get_access_token(self):

        if self.__token_expiration < datetime.now():
            if self.__refresh_token_expiration < datetime.now():
                self.__retrieve_token()
            else:
                self.__refresh_token()

        if not self.__token:
            self.__retrieve_token()
        access_token = self.__token.get("access_token", None)
        if access_token:
            return access_token

    def __get_headers(self):
        return {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
           # 'Authorization': 'Bearer ' + access_token
        }
        if not self.__token:
            self.__retrieve_token()
        access_token = self.__get_access_token()

        headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
           # 'Authorization': 'Bearer ' + access_token
        }
        return headers

    def unwrap_result(self, result, allow_none=False, allowed_status_codes=None):
        if not allowed_status_codes:
            allowed_status_codes = []

        if result.status_code == 200:
            data = result.json()

            if data is not None:
                return data
            else:
                if allow_none:
                    return None
                else:
                    raise ValueError("No data found for url %s" % result.url)
        elif result.status_code in allowed_status_codes:
            return None
        else:
            raise ValueError("Request for url %s failed with status code: %s and reason %s " % (
                result.url, result.status_code, result.text))

    @retry(tries=5, backoff=2, delay=1, max_delay=30, logger=logger)
    def get(self, path, allow_none=False, allowed_status_codes=None):
        result = requests.get(
            url=self.build_url(path),
            headers=self.__get_headers()
        )
        return self.unwrap_result(result, allow_none=allow_none, allowed_status_codes=allowed_status_codes)

    @retry(tries=5, backoff=2, delay=1, max_delay=30, logger=logger)
    def post(self, path, data, allow_none=False, allowed_status_codes=None):
        result = requests.post(
            url=self.build_url(path),
            headers=self.__get_headers(),
            data=self.to_json(data)
        )
        return self.unwrap_result(result, allow_none=allow_none, allowed_status_codes=allowed_status_codes)

    @retry(tries=5, backoff=2, delay=1, max_delay=30, logger=logger)
    def put(self, path, data, allow_none=False, allowed_status_codes=None):
        result = requests.put(
            url=self.build_url(path),
            headers=self.__get_headers(),
            data=self.to_json(data)
        )
        return self.unwrap_result(result, allow_none=allow_none, allowed_status_codes=allowed_status_codes)

    @retry(tries=5, backoff=2, delay=1, max_delay=30, logger=logger)
    def delete(self, path, allow_none=True, allowed_status_codes=None):
        result = requests.delete(
            url=self.build_url(path),
            headers=self.__get_headers()
        )
        return self.unwrap_result(result, allow_none=allow_none, allowed_status_codes=allowed_status_codes)

    def to_json(self, data):
        if type(data) == list:
            new_data = [self.__clean_data(item) for item in data]
        else:
            new_data = self.__clean_data(data)

        json_data = json.dumps(
            new_data,
            sort_keys=True,
            default=str
        )
        return json_data

    def __clean_data(self, data):
        new_data = {}
        for k, v in data.items():
            if v is not None:
                new_data[k] = v
        if "modified_on" in new_data.keys():
            del new_data["modified_on"]
        return new_data